* Интро
Графические инструменты, позволяющие рисовать графики.

* Реализация

На данный момент реализовано в зачаточном варианте:
- заполнение графика заданным фоновым цветом
- рисование линий, которые могут лежать как на одной рямой, так и нет
- рисование осей заданным цветом
- рисование делений на осях
- сохранение изображения
- вывод наиболее частых ошибок


Генерация графика по заболеваемости:
- ось X - это время, ось Y - кол-во инфицированных
- каждое деление оси X - это 3 недели времени
-
#+NAME
#+BEGIN_SRC lisp :tangle
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")

  (defparameter *test-image-path* "./test.png")
  (defparameter *default-width* 700)
  (defparameter *default-height* 500)
  (defparameter *default-array* (zpng:data-array (make-instance 'zpng:png
                                                                :color-type :truecolor-alpha
                                                                :width *default-width*
                                                                :height *default-height*)))
  (defparameter *expected-truecolor-alpha-error*
    "WRONG IMAGE FORMAT: expected truecolor-alpha")

  (defparameter *coordinates-error*
    "WRONG COORDINATES: coordinates outside the array")

  (defparameter *too-long-axes-error*
    "TOO-LONG-AXES: axes length is too big!")

  ;; сохраняет массив в виде изображения
  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

  ;; Печатает сообщение об ошибке
  ;; Принимает имя функции, в которой произошла ошибка,  и строку, которую надо вывести
  (defun print-error (func-name string)
    (format t "~A: ~A ~%" func-name string))

  ;; Макрос позволяет записать в пиксель, расположенный в массиве
  ;; по координатам X и Y значение RGB. Эта операция будет часто повторяться,
  ;; поэтому вынесена в макрос.
  (defmacro write-to-array (array x y r g b)
    `(setf (aref ,array ,y ,x 0) ,b
           (aref ,array ,y ,x 1) ,g
           (aref ,array ,y ,x 2) ,r
           (aref ,array ,y ,x 3) 255))

  ;; (macroexpand-1 '(write-to-array *default-array* 1 2 34 56 78))

  ;; заполняет массив фоновым цветом
  (defun write-background-color-trucolor (array r g b)
    (destructuring-bind (hight width format)
        (array-dimensions array)
      (if (= format 4)
          (do ((x 0 (incf x)))
              ((= x width))
            (do ((y 0 (incf y)))
                ((= y hight))
              (write-to-array array x y r g b)))
          (print-error 'write-background-color-trucolor
                       ,*expected-truecolor-alpha-error*))))


  ;; (write-background-color-trucolor *default-array* 0 255 0 )
  ;; (save-png (array-dimension *default-array* 0)
  ;;           (array-dimension *default-array* 1)
  ;;           "./test.png"
  ;;           *default-array*)


  ;; Реализация алгоритма Брезенхайма - позволяет соединять 2 точки,
  ;; ТОЛЬКО лежащие НЕ на одной прямой
  (defun bresenham-algorithm (array x0 y0 x1 y1 r g b)
    (bresenham-algorithm-rec array x0 y0 x1 y1 0 r g b))

  (defun bresenham-algorithm-rec (array x0 y0 x1 y1 error-rate r g b)
    (format t "x0 ~A y0 ~A x1 ~A y1 ~A ~%" x0 y0 x1 y1)
    (if (and (= x0 x1) (= y0 y1))
        'done
        (let* ((angle (* (/ (- y1 y0) (- x1 x0)) 1.0))
               (new-error-rate (+ error-rate angle)))
          (write-to-array array x0 y0 r g b)
          (if (<= new-error-rate 0.5)
              (bresenham-algorithm-rec array (incf x0) y0 x1 y1 new-error-rate r g b)
              (bresenham-algorithm-rec array (incf x0) (incf y0) x1 y1
                                       (- new-error-rate 1) r g b)))))

  ;; (defun test-bresenham-algorithm()
  ;;   (write-background-color-trucolor *default-array* 255 255 255)
  ;;   (bresenham-algorithm *default-array* 3 3 300 244 255 0 0)
  ;;   (save-png (array-dimension *default-array* 1)
  ;;             (array-dimension *default-array* 0)
  ;;             "./test.png"
  ;;             *default-array*))
  ;; (test-bresenham-algorithm)


  ;; Рисует ПРЯМУЮ линию от точки А до точки В
  (defun write-straight-line (array x0 y0 x1 y1 r g b)
    (destructuring-bind (hight width format)
        (array-dimensions array)
      (if (or (>= y1 hight)
              (>= x1 width))
          (print-error 'write-straight-line
                       ,*coordinates-error*)
          (if (not (= format 4))
              (print-error 'write-straight-line
                           ,*expected-truecolor-alpha-error*)
              (if (= x0 x1)
                  (do ((y y0 (decf y)))
                      ((= y y1))
                    (write-to-array array x0 y r g b))
                  (do ((x x0 (incf x)))
                      ((= x x1))
                    (write-to-array array x y0 r g b)))))))


  ;; Рисует ЛЮБУЮ линию от точки А до точки В
  (defun write-any-line (array x0 y0 x1 y1 r g b)
    (if (or (= x0 x1)
            (= y0 y1))
        ;; точки лежат на одной прямой
        (write-straight-line array x0 y0 x1 y1 r g b)
        ;; точки НЕ лежат на одной прямой
        (bresenham-algorithm array x0 y0 x1 y1 r g b)))


  ;; Отрисовывает оси X и Y
  ;; PARAMS
  ;; - массив изображения
  ;; - длина осей x и y в пикселях
  ;; - цвет в формате RGB
  (defun write-axises (array x-axis-length y-axis-length r g b)
    (destructuring-bind (hight width format)
        (array-dimensions array)
      ;; чтоб не рисовать от края изображения, высчитываем отступ
      ;; в 10% от границы изображения
      (let* ((x0 (* ( floor width 100) 10))
             (y0 (* ( floor hight 100) 90))
             (x1 (+ x0 x-axis-length))
             (y1 (- y0 y-axis-length)))
        (if (or (< y1 0) (> x1 width))
            (print-error 'write-axises *too-long-axes-error*)
            (if (not (= format 4))
                (print-error
                 'write-axises *expected-truecolor-alpha-error*)
                (progn
                  ;; отрисовываем ось Y
                  (write-straight-line array x0 y0 x0 y1 r g b)
                  ;; отрисовываем ось X
                  (write-straight-line array x0 y0 x1 y0 r g b)))))))

  ;; (defun test-write-axises()
  ;;   (write-background-color-trucolor *default-array* 255 255 255)
  ;;   (write-axises *default-array* 200 200 255 56 98)
  ;;   (save-png (array-dimension *default-array* 1)
  ;;             (array-dimension *default-array* 0)
  ;;             "./test.png"
  ;;             *default-array*))

  ;; Рисует заданное кол-во делений на осях, самостоятельно высчитывая размер
  ;; делений и рассояние между ними
  ;; # PARAMS: #
  ;; - массив изображения
  ;; - длина осей в пикселях
  ;; - цвет для делений (задается RGB)
  ;; - кол-во делений
  ;; # RETURN VALUE: #
  ;; возвращает список, состоящий из 2х подсписков
  ;; первый подсписок содержит в себе список координат, отображающих делений на оси X
  ;; второй подсписок содержит в себе аналогичный список для делений по оси Y
  (defun write-divs-on-axises (array x-axis-length y-axis-length r g b divs)
    (destructuring-bind (hight width format)
        (array-dimensions array)
      (let* ((start-x (* ( floor width 100) 10))
             (start-y (* ( floor hight 100) 90))
             (divs-y-pixels (floor y-axis-length divs))
             (divs-x-pixels (floor x-axis-length divs))
             (divs-size (* ( floor width 100) 2))
             (y-divs-list '())
             (x-divs-list '()))
        ;; (format t "divs-size ~A ~%" divs-size)
        (if (or (< (- start-y y-axis-length) 0)
                (> (+ start-x x-axis-length) width))
            (print-error 'write-divs-on-axises *too-long-axes-error*)
            (if (= format 4)
                (progn
                  ;; двигаемся по оси x слева направо
                  ;; рисуя еделния через каждые n пикселей
                  (do ((x start-x (+ x divs-x-pixels)))
                      ((>= x (+ start-x x-axis-length)))
                    ;; рисуем деления длины n на оси x
                    ;; координата x не меняяется
                    (setf x-divs-list (append x-divs-list
                                              (list (cons x start-y))))
                    (do ((y start-y (incf y)))
                        ((= y (+ start-y divs-size)))
                      (write-to-array array x y r g b)))

                  ;; двигаемся по оси Y, двигаясь сверху вниз
                  ;; и рисуя через каждые n пикселейни деления
                  (do ((y start-y (- y divs-y-pixels)))
                      ((<= y (- start-y y-axis-length)))
                    ;; рисуем деления длины n на оси y
                    ;; координата Y не меняется
                    (setf y-divs-list (append y-divs-list
                                              (list (cons start-x y))))
                    (do ((x start-x (decf x)))
                        ((= x (- start-x divs-size)))
                      (write-to-array array x y r g b)))
                  (values x-divs-list y-divs-list))
                (print-error 'write-divs-on-axises *expected-truecolor-alpha-error*))))))

  ;; (defun write-divs-on-axises-test()
  ;;   (write-background-color-trucolor *default-array* 255 255 255)
  ;;   (write-axises *default-array* 110 110 54 98 23)
  ;;   (write-divs-on-axises *default-array* 110 110 200 13 20 10)
  ;;   (save-png (array-dimension *default-array* 0)
  ;;             (array-dimension *default-array* 1)
  ;;             "./test.png"
  ;;             *default-array*))

  ;; (write-divs-on-axises-test)

  ;; Отрисовывает точки на графе
  ;; # PARAMS #
  ;; - массив изображения
  ;; - ассоциативный (!) список координат, где car подсписка - координата X
  ;; - цвет в формате RGB, которым отрисовываются точки
  (defun write-points (array points-list r g b)
    (destructuring-bind (hight width format)
        (array-dimensions array)
      (if (< format 4)
          (print-error 'write-points *expected-truecolor-alpha-error*)
          (write-points-rec array points-list hight width r g b))))

  (defun write-points-rec (array points-list hight width r g b)
    (if (null points-list)
        'done
        (let ((x (caar points-list))
              (y (cdar points-list)))
          (if (or (>= x width)
                  (>= y hight))
              (print-error 'write-points-rec *coordinates-error*)
              (progn
                (write-to-array array x y r g b)
                (write-points-rec array
                                  (cdr points-list) hight width r g b))))))

  ;; (defun test-write-points-rec()
  ;;   (write-background-color-trucolor *default-array* 255 255 255)
  ;;   (multiple-value-bind (l1 l2)
  ;;       (write-divs-on-axises *default-array* 110 110 255 255 255 10)
  ;;     (write-points *default-array* l1 0 0 0 )
  ;;     (write-points *default-array* l2 0 0 0 ))
  ;;   (save-png (array-dimension *default-array* 0)
  ;;             (array-dimension *default-array* 1)
  ;;             "./test.png"
  ;;             *default-array*))
  ;; (test-write-points-rec)


  (defun count-rec (chance healthy infected limit period time list-of-points)
    (if (<= (- limit infected) 0.001)
        list-of-points
        (let* ((new-infected (floor (* (/ healthy 100) chance) 1.0))
               (still-healthy (- healthy new-infected)))
          (setf list-of-points (append list-of-points (list
                                                       (cons time
                                                             (+ new-infected infected)))))
          (count-rec chance still-healthy (+ new-infected infected)
                     limit period (+ period time) list-of-points))))


  (defun cnt (chance amount limit period)
    (count-rec chance amount 0 limit period 0 '()))


  ;; ДОДЕЛАТЬ:
  ;; - ось Y идет не снизу вверх, а сверху вниз (у нее 0 в левом верхнем углу)
  ;; восходящий график рисуется как нисходящий и наоборот
  ;; - отрисовывать оси и деления на них
  ;; - сделать так, чтоб график начинался от начала системы координат

  (defun generate-graphic (array list-of-points r g b)
    ;; (format t "list-of-points ~A~%" list-of-points)
    (if (= (length list-of-points) 1)
        'done
        (let* ((point1 (car list-of-points))
               (point2 (cadr list-of-points))
               (x1 (car point1))
               (y1 (cdr point1))
               (x2 (car point2))
               (y2 (cdr point2)))
          (write-any-line array x1 y1 x2 y2 r g b)
          (generate-graphic array (cdr list-of-points) r g b))))

  (defun generate-corona-graphic-desease (array chance healthy infected-limit period)
    (let ((list-of-points (cnt chance healthy infected-limit period)))
      (write-background-color-trucolor array 255 255 255)
      (generate-graphic array list-of-points 255 0 0)
        (save-png (array-dimension *default-array* 1)
                  (array-dimension *default-array* 0)
                  "./test.png"
                  array)))

  ;; (generate-corona-graphic-desease *default-array* 1.879 200 100 3)



#+END_SRC
